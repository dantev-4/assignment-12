"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, <Dante Villarreal> and <FULL NAME>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: djv797
UT EID 2:
"""


import sys


class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next


class StackError(Exception):
    pass


class Stack:
    def __init__(self):
        self._top = None
        self._size = 0

    def peek(self):
        if self.is_empty():
            raise StackError("Peek from empty stack.")
        return self._top.data

    def push(self, item):
        new_node = Node(item)
        new_node.next = self._top
        self._top = new_node
        self._size += 1

    def pop(self):
        if self.is_empty():
            raise StackError("Pop from empty stack.")
        removed_data = self._top.data
        self._top = self._top.next
        self._size -= 1
        return removed_data

    def is_empty(self):
        return self._top is None

    def size(self):
        return self._size


class QueueError(Exception):
    pass


class Queue:
    def __init__(self):
        self._front = None
        self._rear = None
        self._size = 0

    def peek(self):
        if self.is_empty():
            raise QueueError("Peek from empty queue.")
        return self._front.data

    def enqueue(self, item):
        new_node = Node(item)
        if self.is_empty():
            self._front = new_node
        else:
            self._rear.next = new_node
        self._rear = new_node
        self._size += 1

    def dequeue(self):
        if self.is_empty():
            raise QueueError("Dequeue from empty queue.")
        front_data = self._front.data
        self._front = self._front.next
        if self._front is None:
            self._rear = None
        self._size -= 1
        return front_data

    def is_empty(self):
        return self._size == 0

    def size(self):
        return self._size


class Vertex:
    def __init__(self, label):
        self.__label = label
        self.visited = False

    @property
    def visited(self):
        return self.__visited

    @visited.setter
    def visited(self, value):
        if isinstance(value, bool):
            self.__visited = value
        else:
            raise ValueError("Visited status must be a boolean value.")

    @property
    def label(self):
        return self.__label

    def __str__(self):
        return str(self.__label)


class Graph:
    def __init__(self):
        self.vertices = []
        self.adjacency_matrix = []

    def has_vertex(self, label):
        num_vertices = len(self.vertices)
        for i in range(num_vertices):
            if label == self.vertices[i].label:
                return True
        return False

    def get_index(self, label):
        num_vertices = len(self.vertices)
        for i in range(num_vertices):
            if label == self.vertices[i].label:
                return i
        return -1

    def add_vertex(self, label):
        if self.has_vertex(label):
            return

        self.vertices.append(Vertex(label))
        num_vertices = len(self.vertices)
        for i in range(num_vertices - 1):
            self.adjacency_matrix[i].append(0)

        new_row = []
        for i in range(num_vertices):
            new_row.append(0)
        self.adjacency_matrix.append(new_row)

    def add_edge(self, start, finish):
        self.adjacency_matrix[start][finish] = 1

    def get_adjacent_vertices(self, vertex_index):
        vertices = []
        num_vertices = len(self.vertices)
        for j in range(num_vertices):
            if self.adjacency_matrix[vertex_index][j]:
                vertices.append(j)
        return vertices

    def has_cycle(self):
        visited = [False] * len(self.vertices)
        path = [False] * len(self.vertices)

        for i in range(len(self.vertices)):
            if not visited[i]:
                stack = [i]
                while stack:
                    current = stack.pop()
                    if not visited[current]:
                        visited[current] = path[current] = True
                        stack.extend(self.get_adjacent_vertices(current))
                    elif path[current]:
                        return True
                path[current] = False
        return False

    def get_registration_plan(self):
        temp_vertices = list(self.vertices)
        temp_matrix = [row[:] for row in self.adjacency_matrix]
        plan = []

        while temp_vertices:
            semester = []
            removable = []

            for i, vertex in enumerate(temp_vertices):
                if all(temp_matrix[j][i] == 0 for j in range(len(temp_matrix))):
                    semester.append(vertex.label)
                    removable.append(i)

            for index in sorted(removable, reverse=True):
                self.delete_vertex_from_copy(temp_vertices[index].label, temp_matrix, temp_vertices)

            plan.append(semester)

        return plan

    def delete_vertex_from_copy(self, vertex_label, adjacency_matrix_copy, vertices_copy):
        index = self.get_index_from_copy(vertex_label, vertices_copy)
        for row in adjacency_matrix_copy:
            del row[index]
        del adjacency_matrix_copy[index]
        del vertices_copy[index]

    def get_index_from_copy(self, label, vertices_copy):
        for i, vertex in enumerate(vertices_copy):
            if vertex.label == label:
                return i
        return -1


def main():
    graph = Graph()

    num_vertices = int(input().strip())
    vertices = [input().strip() for _ in range(num_vertices)]
    for label in vertices:
        graph.add_vertex(label)

    num_edges = int(input().strip())
    for _ in range(num_edges):
        start, finish = input().strip().split()
        graph.add_edge(graph.get_index(start), graph.get_index(finish))

    if graph.has_cycle():
        print("Registration plan invalid because a cycle was detected.")
    else:
        print("Valid registration plan detected.")

        courses = graph.get_registration_plan()
        print()
        print("Registration plan: ")
        for semester in courses:
            print(semester)


if __name__ == "__main__":
    main()
